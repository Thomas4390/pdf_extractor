"""
UV Assurance Remuneration Report Extractor

This module allows extracting and structuring data from remuneration reports
in PDF format generated by UV Assurance. It supports multi-page extraction and handles
cases where a single contract has multiple protections.

Author: Thomas
Date: 2025-10-20
"""

import pdfplumber
import pandas as pd
import re
from typing import List, Optional, Dict


class RemunerationReportExtractor:
    """
    Robust extractor for UV Assurance remuneration reports.

    This class allows automatically extracting the following information:
    - Report date
    - Advisor name and number
    - Activity details (contracts, insured parties, protections, remunerations)

    Column names are kept in French as they appear in the original document.
    """

    def __init__(self, pdf_path: str):
        """
        Initialize the extractor with the PDF file path.

        Args:
            pdf_path: Path to the PDF file to process
        """
        self.pdf_path = pdf_path

    def extract_report_date(self, text: str) -> Optional[str]:
        """
        Extract the report date from the text.

        Args:
            text: Text containing the report date

        Returns:
            Date in YYYY-MM-DD format or None if not found
        """
        pattern = r'RAPPORT\s+DE\s+R√âMUN√âRATION\s+DU\s+(\d{4}-\d{2}-\d{2})'
        match = re.search(pattern, text, re.IGNORECASE)

        if match:
            return match.group(1)

        # Try with an alternative pattern
        pattern_alt = r'DU\s+(\d{4}-\d{2}-\d{2})'
        match = re.search(pattern_alt, text)
        if match:
            return match.group(1)

        return None

    def extract_advisor_name(self, text: str) -> Optional[str]:
        """
        Extract the advisor name from the text.

        Args:
            text: Text containing the advisor information

        Returns:
            Advisor name or None if not found
        """
        pattern = r'Nom\s+du\s+conseiller\s*:?\s*(.+?)(?:\n|Num√©ro)'
        match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)

        if match:
            return match.group(1).strip()

        return None

    def extract_advisor_number(self, text: str) -> Optional[str]:
        """
        Extract the advisor number from the text.

        Args:
            text: Text containing the advisor information

        Returns:
            Advisor number or None if not found
        """
        pattern = r'Num√©ro\s+du\s+conseiller\s*:?\s*(\d+)'
        match = re.search(pattern, text, re.IGNORECASE)

        if match:
            return match.group(1).strip()

        return None

    def clean_amount(self, amount: str) -> float:
        """
        Clean and convert a monetary amount to float.

        Args:
            amount: String containing the amount (e.g., "1 196,00 $")

        Returns:
            Amount as float
        """
        if not amount or pd.isna(amount):
            return 0.0

        # Remove symbols and spaces, replace comma with period
        amount_clean = str(amount).replace('$', '').replace(' ', '').replace(',', '.')

        try:
            return float(amount_clean)
        except ValueError:
            return 0.0

    def clean_percentage(self, pct: str) -> float:
        """
        Clean and convert a percentage to float.

        Args:
            pct: String containing the percentage (e.g., "55,000 %")

        Returns:
            Percentage as float
        """
        if not pct or pd.isna(pct):
            return 0.0

        # Remove % symbol and spaces, replace comma with period
        pct_clean = str(pct).replace('%', '').replace(' ', '').replace(',', '.')

        try:
            return float(pct_clean)
        except ValueError:
            return 0.0

    def get_column_names(self) -> List[str]:
        """
        Return column names in French as they appear in the document.

        Returns:
            List of column names
        """
        return [
            'Contrat',
            'Assur√©(s)',
            'Protection',
            'Montant de base',
            'Taux de partage',
            'Taux de commission',
            'R√©sultat',
            'Type',
            'Taux de Boni',
            'R√©mun√©ration'
        ]

    def is_header_row(self, row: List) -> bool:
        """
        Check if a row is a table header (to be ignored).

        Args:
            row: List of row values

        Returns:
            True if the row is a header, False otherwise
        """
        if not row or not any(row):
            return True

        # Convert row to string for verification
        row_str = ' '.join([str(cell).lower() if cell else '' for cell in row])

        # Header keywords
        header_keywords = [
            'contrat',
            'assur√©',
            'protection',
            'montant de base',
            'taux de partage',
            'taux de commission',
            'r√©sultat',
            'r√©mun√©ration',
            'type'
        ]

        # If the row contains multiple header keywords, it's probably a header
        keyword_count = sum(1 for kw in header_keywords if kw in row_str)
        if keyword_count >= 3:
            return True

        # Check for summary/total rows to ignore
        skip_keywords = ['total', 'sommaire', 'page', 'sous-total']
        if any(kw in row_str for kw in skip_keywords):
            return True

        return False

    def is_valid_data_row(self, row: List) -> bool:
        """
        Check if a row contains valid data.

        Accepts two types of rows:
        1. Rows with contract number (110xxxxxx)
        2. Continuation rows (same insured party, additional protection)

        Args:
            row: List of row values

        Returns:
            True if the row contains valid data, False otherwise
        """
        if not row or len(row) < 9:
            return False

        if not any(row):
            return False

        first_cell = str(row[0]).strip() if row[0] else ''
        second_cell = str(row[1]).strip() if row[1] else ''

        # Case 1: First cell contains a contract number (starts with 110)
        if re.match(r'110\d{6}', first_cell):
            return True

        # Case 2: Continuation row (first cell empty, second cell contains a name)
        # This occurs when the same person has multiple protections
        if not first_cell and second_cell and len(second_cell) > 2:
            if not self.is_header_row(row):
                return True

        return False

    def extract_table_from_page(self, page, page_num: int) -> List:
        """
        Extract the table from a single page.

        Args:
            page: pdfplumber page object
            page_num: Page number (for tracking)

        Returns:
            List of rows extracted from this page
        """
        page_rows = []

        # Try different extraction parameters for more robustness
        settings_list = [
            {
                "vertical_strategy": "lines",
                "horizontal_strategy": "lines",
                "intersection_tolerance": 3,
            },
            {
                "vertical_strategy": "text",
                "horizontal_strategy": "text",
            },
            {
                "vertical_strategy": "lines",
                "horizontal_strategy": "text",
            }
        ]

        for settings in settings_list:
            table = page.extract_table(table_settings=settings)

            if table and len(table) > 0:
                for row in table:
                    # Ignore headers
                    if self.is_header_row(row):
                        continue

                    # Keep only valid data rows
                    if self.is_valid_data_row(row):
                        page_rows.append(row)

            if page_rows:
                # If data was found with these parameters, don't try the others
                return page_rows

        return page_rows

    def extract_table_pdfplumber(self, pdf) -> List:
        """
        Extract the table from all pages of the PDF.

        Args:
            pdf: pdfplumber PDF object

        Returns:
            List of all rows extracted from all pages
        """
        all_rows = []

        for page_num, page in enumerate(pdf.pages, start=1):
            page_rows = self.extract_table_from_page(page, page_num)
            all_rows.extend(page_rows)

        return all_rows

    def fill_missing_contract_numbers(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Fill missing contract numbers with the previous number.

        Handles cases where the same person has multiple protections
        (subsequent rows don't have a contract number).

        Args:
            df: DataFrame with potentially missing contract numbers

        Returns:
            DataFrame with contract numbers filled
        """
        if df.empty:
            return df

        df_filled = df.copy()

        # Forward fill contract numbers
        df_filled['Contrat'] = df_filled['Contrat'].replace('', None).ffill()

        return df_filled

    def extract_table(self, pdf) -> pd.DataFrame:
        """
        Main table extraction method.

        Args:
            pdf: pdfplumber PDF object

        Returns:
            DataFrame with extracted data
        """
        rows = self.extract_table_pdfplumber(pdf)

        if rows:
            df = pd.DataFrame(rows, columns=self.get_column_names())
            # Fill missing contract numbers for continuation rows
            df = self.fill_missing_contract_numbers(df)
            return df

        return pd.DataFrame(columns=self.get_column_names())

    def clean_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Clean and format the extracted DataFrame.

        Args:
            df: Raw DataFrame

        Returns:
            Cleaned and formatted DataFrame
        """
        if df.empty:
            return df

        df_clean = df.copy()

        # Clean numeric columns
        df_clean['Montant de base'] = df_clean['Montant de base'].apply(self.clean_amount)
        df_clean['Taux de partage'] = df_clean['Taux de partage'].apply(self.clean_percentage)
        df_clean['Taux de commission'] = df_clean['Taux de commission'].apply(self.clean_percentage)
        df_clean['R√©sultat'] = df_clean['R√©sultat'].apply(self.clean_amount)
        df_clean['Taux de Boni'] = df_clean['Taux de Boni'].apply(self.clean_percentage)
        df_clean['R√©mun√©ration'] = df_clean['R√©mun√©ration'].apply(self.clean_amount)

        # Clean text columns (remove line breaks and excess spaces)
        text_columns = ['Contrat', 'Assur√©(s)', 'Protection', 'Type']
        for col in text_columns:
            if col in df_clean.columns:
                df_clean[col] = (df_clean[col]
                                 .astype(str)
                                 .str.replace('\n', ' ', regex=False)
                                 .str.replace(r'\s+', ' ', regex=True)
                                 .str.strip())

        return df_clean

    def extract_all(self) -> Dict:
        """
        Extract all information from the PDF into a dictionary.

        Returns:
            Dictionary containing:
            - date: Report date
            - nom_conseiller: Advisor name (French key)
            - numero_conseiller: Advisor number (French key)
            - activites: DataFrame of detailed activities (French key)
        """
        result = {
            'date': None,
            'nom_conseiller': None,
            'numero_conseiller': None,
            'activites': None
        }

        try:
            with pdfplumber.open(self.pdf_path) as pdf:
                # Extract text from first page for metadata
                first_page = pdf.pages[0]
                text = first_page.extract_text()

                # Extract metadata
                result['date'] = self.extract_report_date(text)
                result['nom_conseiller'] = self.extract_advisor_name(text)
                result['numero_conseiller'] = self.extract_advisor_number(text)

                # Extract table from all pages
                raw_df = self.extract_table(pdf)

                if raw_df.empty:
                    print("‚ùå ERROR: No data could be extracted from the PDF")
                    return result

                # Clean the data
                result['activites'] = self.clean_dataframe(raw_df)

                return result

        except FileNotFoundError:
            print(f"‚ùå ERROR: File not found: {self.pdf_path}")
            return result
        except Exception as e:
            print(f"‚ùå ERROR: {str(e)}")
            import traceback
            traceback.print_exc()
            return result

    def display_results(self, data: Dict):
        """
        Display all extracted data from the dictionary.

        Args:
            data: Dictionary containing extracted data
        """
        # Configure pandas display
        pd.set_option('display.max_columns', None)
        pd.set_option('display.width', None)
        pd.set_option('display.max_colwidth', 30)
        pd.set_option('display.float_format', lambda x: f'{x:,.2f}')

        print("\n" + "=" * 100)
        print("EXTRACTED DATA - REMUNERATION REPORT")
        print("=" * 100)

        # Display date
        print("\n" + "-" * 100)
        print("üìÖ DATE")
        print("-" * 100)
        print(f"{data['date']}")

        # Display advisor name
        print("\n" + "-" * 100)
        print("üë§ ADVISOR NAME")
        print("-" * 100)
        print(f"{data['nom_conseiller']}")

        # Display advisor number
        print("\n" + "-" * 100)
        print("üî¢ ADVISOR NUMBER")
        print("-" * 100)
        print(f"{data['numero_conseiller']}")

        # Display activities table
        print("\n" + "-" * 100)
        print("üìä DETAILED ACTIVITIES")
        print("-" * 100)

        if data['activites'] is not None and not data['activites'].empty:
            df = data['activites']

            # Count unique contracts
            unique_contracts = df['Contrat'].nunique()
            total_rows = len(df)

            print(f"\nTotal number of rows: {total_rows}")
            print(f"Number of unique contracts: {unique_contracts}")
            print(f"Multiple protections: {total_rows - unique_contracts}")
            print()
            print(df.to_string(index=False))
            print(f"\nTOTAL REMUNERATION: {df['R√©mun√©ration'].sum():,.2f} $")
        else:
            print("\nNo activity data available")

        print("\n" + "=" * 100 + "\n")


# ===========================
# USAGE
# ===========================

if __name__ == "__main__":
    # Path to PDF file
    pdf_path = "../pdf/rappportremun_21622_2025-10-20.pdf"

    # Create extractor
    extractor = RemunerationReportExtractor(pdf_path)

    # Extract all data into a dictionary
    data = extractor.extract_all()

    # Display all results
    extractor.display_results(data)

    # Example of accessing individual elements
    if data['activites'] is not None:
        df = data['activites']

        # Examples of possible analyses
        print("\n" + "=" * 100)
        print("QUICK STATISTICS")
        print("=" * 100)
        print(f"Report date: {data['date']}")
        print(f"Advisor: {data['nom_conseiller']}")
        print(f"Advisor number: {data['numero_conseiller']}")
        print(f"Number of contracts: {df['Contrat'].nunique()}")
        print(f"Total number of protections: {len(df)}")
        print(f"Total remuneration: {df['R√©mun√©ration'].sum():,.2f} $")
        print(f"Average remuneration per protection: {df['R√©mun√©ration'].mean():,.2f} $")
        print("=" * 100)